/* Generated with shader-compressor by NR4/Team210. */
#ifndef GFX_H
#define GFX_H
const char * gfx_frag =
"/* Endeavor by Team210 - 64k intro by Team210 at Revision 2k19\n"
"* Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n"
"*\n"
"* This program is free software: you can redistribute it and/or modify\n"
"* it under the terms of the GNU General Public License as published by\n"
"* the Free Software Foundation, either version 3 of the License, or\n"
"* (at your option) any later version.\n"
"*\n"
"* This program is distributed in the hope that it will be useful,\n"
"* but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"* GNU General Public License for more details.\n"
"*\n"
"* You should have received a copy of the GNU General Public License\n"
"* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n"
"*/\n"
"\n"
"#version 330\n"
"\n"
"float iScale, iNBeats = 0.;\n"
"uniform float iTime, iFontWidth, iSequenceWidth, iExecutableSize;\n"
"uniform vec2 iResolution;\n"
"uniform sampler2D iFont, iSequence;\n"
"uniform int iFSAA, iTXAA;\n"
"\n"
"// Global constants\n"
"const vec3 c = vec3(1.,0.,-1.);\n"
"const float pi = acos(-1.);\n"
"float a; // Aspect ratio\n"
"\n"
"// Read short value from texture at index off\n"
"float rshort(float off)\n"
"{\n"
"    // Parity of offset determines which byte is required.\n"
"    float hilo = mod(off, 2.);\n"
"    // Find the pixel offset your data is in (2 unsigned shorts per pixel).\n"
"    off *= .5;\n"
"    // - Determine texture coordinates.\n"
"    //     offset = i*iFontWidth+j for (i,j) in [0,iFontWidth]^2\n"
"    //     floor(offset/iFontWidth) = floor((i*iFontwidth+j)/iFontwidth)\n"
"    //                              = floor(i)+floor(j/iFontWidth) = i\n"
"    //     mod(offset, iFontWidth) = mod(i*iFontWidth + j, iFontWidth) = j\n"
"    // - For texture coordinates (i,j) has to be rescaled to [0,1].\n"
"    // - Also we need to add an extra small offset to the texture coordinate\n"
"    //   in order to always \"hit\" the right pixel. Pixel width is\n"
"    //     1./iFontWidth.\n"
"    //   Half of it is in the center of the pixel.\n"
"    vec2 ind = (vec2(mod(off, iFontWidth), floor(off/iFontWidth))+.05)/iFontWidth;\n"
"    // Get 4 bytes of data from the texture\n"
"    vec4 block = texture(iFont, ind);\n"
"    // Select the appropriate word\n"
"    vec2 data = mix(block.rg, block.ba, hilo);\n"
"    // Convert bytes to unsigned short. The lower bytes operate on 255,\n"
"    // the higher bytes operate on 65280, which is the maximum range \n"
"    // of 65535 minus the lower 255.\n"
"    return round(dot(vec2(255., 65280.), data));\n"
"}\n"
"\n"
"// Read float value from texture at index off\n"
"float rfloat(float off)\n"
"{\n"
"    // Convert the bytes to unsigned short as first step.\n"
"    float d = rshort(off);\n"
"    \n"
"    // Convert bytes to IEEE 754 float16. That is\n"
"    // 1 sign bit, 5 bit exponent, 11 bit mantissa.\n"
"    // Also it has a weird conversion rule that is not evident at all.\n"
"    float sign = floor(d/32768.),\n"
"        exponent = floor(d/1024.-sign*32.),\n"
"        significand = d-sign*32768.-exponent*1024.;\n"
"\n"
"    // Return full float16\n"
"    if(exponent == 0.)\n"
"        return mix(1., -1., sign) * 5.960464477539063e-08 * significand;\n"
"    return mix(1., -1., sign) * (1. + significand * 9.765625e-4) * pow(2.,exponent-15.);\n"
"}\n"
"\n"
"// Read short value from texture at index off\n"
"float rshorts(float off)\n"
"{\n"
"    float hilo = mod(off, 2.);\n"
"    off *= .5;\n"
"    vec2 ind = (vec2(mod(off, iSequenceWidth), floor(off/iSequenceWidth))+.05)/iSequenceWidth;\n"
"    vec4 block = texture(iSequence, ind);\n"
"    vec2 data = mix(block.rg, block.ba, hilo);\n"
"    return round(dot(vec2(255., 65280.), data));\n"
"}\n"
"\n"
"// Read float value from texture at index off\n"
"float rfloats(int off)\n"
"{\n"
"    float d = rshorts(float(off));\n"
"    float sign = floor(d/32768.),\n"
"        exponent = floor(d/1024.-sign*32.),\n"
"        significand = d-sign*32768.-exponent*1024.;\n"
"\n"
"    if(exponent == 0.)\n"
"        return mix(1., -1., sign) * 5.960464477539063e-08 * significand;\n"
"    return mix(1., -1., sign) * (1. + significand * 9.765625e-4) * pow(2.,exponent-15.);\n"
"}\n"
"\n"
"// TODO: COPY THIS FROM SFX SHADER TO ACHIEVE SYNC\n"
"const int NTRK = 4, NMOD = 19, NPTN = 5, NNOT = 62;\n"
"\n"
"int trk_sep(int index)      {return int(rfloats(index));}\n"
"int trk_syn(int index)      {return int(rfloats(index+1+1*NTRK));}\n"
"float trk_norm(int index)   {return     rfloats(index+1+2*NTRK);}\n"
"float trk_rel(int index)    {return     rfloats(index+1+3*NTRK);}\n"
"float mod_on(int index)     {return     rfloats(index+1+4*NTRK);}\n"
"float mod_off(int index)    {return     rfloats(index+1+4*NTRK+1*NMOD);}\n"
"int mod_ptn(int index)      {return int(rfloats(index+1+4*NTRK+2*NMOD));}\n"
"float mod_transp(int index) {return     rfloats(index+1+4*NTRK+3*NMOD);}\n"
"int ptn_sep(int index)      {return int(rfloats(index+1+4*NTRK+4*NMOD));}\n"
"float note_on(int index)    {return     rfloats(index+2+4*NTRK+4*NMOD+NPTN);}\n"
"float note_off(int index)   {return     rfloats(index+2+4*NTRK+4*NMOD+NPTN+1*NNOT);}\n"
"float note_pitch(int index) {return     rfloats(index+2+4*NTRK+4*NMOD+NPTN+2*NNOT);}\n"
"float note_vel(int index)   {return     rfloats(index+2+4*NTRK+4*NMOD+NPTN+3*NNOT);}\n"
"\n"
"const float BPM = 35.;\n"
"const float BPS = BPM/60.;\n"
"const float SPB = 60./BPM;\n"
"\n"
"// Extract drum signal\n"
"float scale(float t)\n"
"{\n"
"    float max_mod_off = 12.;\n"
"    int drum_index = 25;\n"
"    float d = 0.;\n"
"\n"
"    // mod for looping\n"
"    float BT = mod(BPS * t, max_mod_off);\n"
"    \n"
"    if(BT > max_mod_off) return 0.;\n"
"    t = SPB*BT;\n"
"    \n"
"    float Bon = 0.;\n"
"    float Boff = 0.;\n"
"    \n"
"    for(int trk = 0; trk < max(NTRK,0); trk++)\n"
"    {\n"
"        if(trk_syn(trk) != drum_index) continue;\n"
"        int tsep = trk_sep(trk);\n"
"        int tlen = trk_sep(trk+1) - tsep;\n"
"\n"
"        int _modU = tlen-1;\n"
"        for(int i=0; i<max(tlen-1,0); i++) if(BT < mod_on(tsep + i + 1)) {_modU = i; break;}\n"
"            \n"
"        int _modL = tlen-1;\n"
"        for(int i=0; i<max(tlen-1,0); i++) if(BT < mod_off(tsep + i) + trk_rel(trk)) {_modL = i; break;}\n"
"        \n"
"        for(int _mod = _modL; _mod <= max(_modL,_modU); _mod++)\n"
"        {\n"
"            float B = BT - mod_on(tsep + _mod);\n"
"\n"
"            int ptn = mod_ptn(tsep + _mod);\n"
"            int psep = ptn_sep(ptn);\n"
"            int plen = ptn_sep(ptn+1) - psep;\n"
"            \n"
"            int _noteU = plen;\n"
"            for(int i=0; i<max(plen,0); i++) if(B < note_on(psep + i + 1)) {_noteU = i; break;}\n"
"\n"
"            int _noteL = plen;\n"
"            for(int i=0; i<max(plen,0); i++) if(B <= note_off(psep + i ) + trk_rel(trk)) {_noteL = i; break;}\n"
"        \n"
"            iNBeats = 0.;\n"
"            for(int _note = _noteL; _note <= max(_noteL, _noteU); _note++)\n"
"            {\n"
"                Bon    = note_on(psep + _note);\n"
"                Boff   = note_off(psep + _note);\n"
"\n"
"                int Bdrum = int(note_pitch(psep + _note));\n"
"                if(Bdrum != 0)\n"
"                {\n"
"                    d = max(d, smoothstep(Bon,Bon+.1,B)*(1.-smoothstep(Bon+.1, Bon+.2, B)));\n"
"                    iNBeats += 1.;\n"
"                }\n"
"            }\n"
"            \n"
"            return d;\n"
"        }\n"
"    }\n"
"    return 0.;\n"
"}\n"
"\n"
"// Hash function\n"
"float rand(vec2 x)\n"
"{\n"
"    return fract(sin(dot(x-1. ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"// One-dimensional perlin noise\n"
"float snoise_1d(float t)\n"
"{\n"
"    float i = floor(t);\n"
"    t = fract(t);\n"
"    t = ((6.*t-15.)*t+10.)*t*t*t;\n"
"    return mix(-1.+2.*rand(i*c.xx), -1.+2.*rand((i+1.)*c.xx), t);\n"
"}\n"
"\n"
"// Two-dimensional perlin noise\n"
"float snoise_2d(vec2 t)\n"
"{\n"
"    vec2 i = floor(t);\n"
"    t = fract(t);\n"
"    //t = ((6.*t-15.)*t+10.)*t*t*t;  // TODO: add this for slower perlin noise\n"
"    t = smoothstep(c.yy, c.xx, t); // TODO: add this for faster value noise\n"
"    vec2 v1 = vec2(rand(i), rand(i+c.xy)),\n"
"        v2 = vec2(rand(i+c.yx), rand(i+c.xx));\n"
"    v1 = c.zz+2.*mix(v1, v2, t.y);\n"
"    return mix(v1.x, v1.y, t.x);\n"
"}\n"
"\n"
"// Multi-frequency simplex noise\n"
"float mfsnoise_2d(vec2 x, float f0, float f1, float phi)\n"
"{\n"
"    float sum = 0.;\n"
"    float a = 1.2;\n"
"    float n = 0.;\n"
"    \n"
"    for(float f = f0; f<max(f0,f1); f = f*2.)\n"
"    {\n"
"        sum = a*snoise_2d(f*x) + sum;\n"
"        a = a*phi;\n"
"        n += 1.;\n"
"    }\n"
"    \n"
"    // Normalization\n"
"    sum *= (1.-phi)/(1.-pow(phi, n));\n"
"    \n"
"    return sum;\n"
"}\n"
"\n"
"// 3D rotational matrix\n"
"mat3 rot(vec3 p)\n"
"{\n"
"    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n"
"        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n"
"        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n"
"}\n"
"\n"
"mat2 rot2(float p)\n"
"{\n"
"    vec2 cs = vec2(cos(p), sin(p));\n"
"    return mat2(cs.x,-cs.y,cs.y, cs.x);\n"
"}\n"
"\n"
"// add object to scene\n"
"vec2 add(vec2 sda, vec2 sdb)\n"
"{\n"
"    return mix(sda, sdb, step(sdb.x, sda.x));\n"
"}\n"
"\n"
"vec2 sub(vec2 sda, vec2 sdb)\n"
"{\n"
"    return mix(-sda, sdb, step(sda.x, sdb.x));\n"
"}\n"
"\n"
"// Distance to line segment\n"
"float lineseg(vec2 x, vec2 p1, vec2 p2)\n"
"{\n"
"    vec2 d = p2-p1;\n"
"    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n"
"}\n"
"\n"
"float lineseg3(vec3 x, vec3 p1, vec3 p2)\n"
"{\n"
"    vec3 d = p2-p1;\n"
"    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n"
"}\n"
"\n"
"// Distance to circle\n"
"float circle(vec2 x, float r)\n"
"{\n"
"    return abs(length(x)-r);\n"
"}\n"
"\n"
"// Distance to circle segment\n"
"float circlesegment(vec2 x, float r, float p0, float p1)\n"
"{\n"
"    float p = atan(x.y, x.x);\n"
"    vec2 philo = vec2(max(p0, p1), min(p0, p1));\n"
"    if((p < philo.x && p > philo.y) || (p+2.*pi < philo.x && p+2.*pi > philo.y) || (p-2.*pi < philo.x && p-2.*pi > philo.y))\n"
"        return abs(length(x)-r);\n"
"    return min(\n"
"        length(x-r*vec2(cos(p0), sin(p0))),\n"
"        length(x-r*vec2(cos(p1), sin(p1)))\n"
"        );\n"
"}\n"
"\n"
"// compute distance to regular polygon\n"
"float dpoly_min(vec2 x, float N, float R)\n"
"{\n"
"    float d = 2.*pi/N,\n"
"        t = mod(acos(x.x/length(x)), d)-.5*d;\n"
"    return R-length(x)*cos(t)/cos(.5*d);\n"
"}\n"
"\n"
"// 2D box\n"
"float box(vec2 x, vec2 b)\n"
"{\n"
"vec2 d = abs(x) - b;\n"
"return length(max(d,c.yy)) + min(max(d.x,d.y),0.);\n"
"}\n"
"\n"
"// Get glyph data from texture\n"
"float dglyph(vec2 x, float ordinal, float size)\n"
"{\n"
"    float dis = box(x, 2.*size*c.xx);\n"
"    if(dis > 0.)\n"
"        return dis+.5*size;\n"
"\n"
"    // Find glyph offset in glyph index\n"
"    float nglyphs = rfloat(1.),\n"
"        offset = 0;\n"
"        \n"
"    for(float i=0.; i<max(nglyphs,0); i+=1.)\n"
"    {\n"
"        float ord = floor(rfloat(2.+2.*i));\n"
"        if(ord == ordinal)\n"
"        {\n"
"            offset = floor(rfloat(2.+2.*i+1.));\n"
"            break;\n"
"        }\n"
"    }\n"
"    \n"
"    if(offset == 0.) return 1.;\n"
"    \n"
"    // Get distance from glyph data\n"
"    float d = 1.;\n"
"    \n"
"    // Lines\n"
"    float nlines = floor(rfloat(offset));\n"
"    offset += 1.;\n"
"    for(float i=0.; i<max(nlines,0); i+=1.)\n"
"    {\n"
"        float x1 = rfloat(offset);\n"
"        offset += 1.;\n"
"        float y1 = rfloat(offset);\n"
"        offset += 1.;\n"
"        float x2 = rfloat(offset);\n"
"        offset += 1.;\n"
"        float y2 = rfloat(offset);\n"
"        offset += 1.;\n"
"        d = min(d, lineseg(x, size*vec2(x1,y1), size*vec2(x2, y2)));\n"
"    }\n"
"    \n"
"    // Circles\n"
"    float ncircles = floor(rfloat(offset));\n"
"    offset += 1.;\n"
"    for(float i=0.; i<max(ncircles,0); i+=1.)\n"
"    {\n"
"        float xc = rfloat(offset);\n"
"        offset += 1.;\n"
"        float yc = rfloat(offset);\n"
"        offset += 1.;\n"
"        float r = rfloat(offset);\n"
"        offset += 1.;\n"
"        d = min(d, circle(x-size*vec2(xc, yc), size*r));\n"
"    }\n"
"    \n"
"    // Circle segments\n"
"    float nsegments = floor(rfloat(offset));\n"
"    offset += 1.;\n"
"    for(float i=0.; i<max(nsegments,0); i+=1.)\n"
"    {\n"
"        float xc = rfloat(offset);\n"
"        offset += 1.;\n"
"        float yc = rfloat(offset);\n"
"        offset += 1.;\n"
"        float r = rfloat(offset);\n"
"        offset += 1.;\n"
"        float phi0 = rfloat(offset);\n"
"        offset += 1.;\n"
"        float phi1 = rfloat(offset);\n"
"        offset += 1.;\n"
"        d = min(d, circlesegment(x-size*vec2(xc,yc), size*r, phi0, phi1));\n"
"    }\n"
"    \n"
"    if(nlines+ncircles+nsegments == 0.)\n"
"        return dis;\n"
"    \n"
"    return d;\n"
"}\n"
"\n"
"// Get distance to string from database\n"
"float dstring(vec2 x, float ordinal, float size)\n"
"{\n"
"    // Get string database offset\n"
"    float stroff0 = floor(rfloat(0.));\n"
"    \n"
"    // Return 1 if wrong ordinal is supplied\n"
"    float nstrings = floor(rfloat(stroff0));\n"
"    if(ordinal >= nstrings)\n"
"    {\n"
"        return 1.;\n"
"    }\n"
"    \n"
"    // Get offset and length of string from string database index\n"
"    float stroff = floor(rfloat(stroff0+1.+2.*ordinal));\n"
"    float len = floor(rfloat(stroff0+2.+2.*ordinal));\n"
"    \n"
"    /* Slower code\n"
"    float d = 1.;\n"
"    for(float i=0.; i<len; i+=1.)\n"
"        d = min(d, dglyph(x-2.1*i*size*c.xy,floor(rfloat(0.+stroff+i)), .8*size));\n"
"    return d;\n"
"    */\n"
"    \n"
"    // Draw glyphs\n"
"    vec2 dx = mod(x-size, 2.*size)-size, \n"
"        ind = ceil((x-dx+size)/2./size);\n"
"    \n"
"    // Bounding box\n"
"    float bound = box(x-size*(len-3.)*c.xy, vec2(size*len, 1.*size));\n"
"    if(bound > 0.)\n"
"    {\n"
"        return bound+.5*size;\n"
"    }\n"
"    return dglyph(dx, floor(rfloat(stroff+ind.x)), .7*size);\n"
"}\n"
"\n"
"// distance to a floating point number string\n"
"// for debugging stuff while shader is loaded\n"
"float dfloat(vec2 x, float num, float size)\n"
"{\n"
"    float d = 1., index = 0.;\n"
"    \n"
"    // Determine sign and output it if present\n"
"    float sign = sign(num), exp = 0.;\n"
"    if(sign<0.)\n"
"    {\n"
"        d = min(d, dglyph(x, 45., .7*size));\n"
"        index += 1.;\n"
"        num *= -1.;\n"
"    }\n"
"    \n"
"    // The first power of ten that floors num to anything not zero is the exponent\n"
"    for(exp = -15.; exp < max(15., -32.+sign); exp += 1.)\n"
"        if(floor(num*pow(10.,exp)) != 0.)\n"
"            break;\n"
"    exp *= -1.;\n"
"    // Determine the significand and output it\n"
"    for(float i = exp; i >= max(exp-5.,-33); i -= 1.)\n"
"    {\n"
"        float po = pow(10.,i);\n"
"        float ca = floor(num/po);\n"
"        num -= ca*po;\n"
"        \n"
"        d = min(d, dglyph(x+.7*size*c.xy-2.*index*size*c.xy, 48.+ca, .7*size));\n"
"        index += 1.;\n"
"        if(i == exp) // decimal point\n"
"        {\n"
"            d = min(d, dglyph(x-2.*index*size*c.xy, 46., .7*size));\n"
"            index += 1.;\n"
"        }\n"
"    }\n"
"    \n"
"    // Output the exponent\n"
"    d = min(d, dglyph(x+.7*size*c.xy-2.*index*size*c.xy, 101., .7*size));\n"
"    index += 1.;\n"
"    if(exp < 0.) // Sign\n"
"    {\n"
"        d = min(d, dglyph(x+.7*size*c.xy-2.*index*size*c.xy, 45., .7*size));\n"
"        index += 1.;\n"
"        exp *= -1.;\n"
"    }\n"
"    float ca = floor(exp/10.);\n"
"    d = min(d, dglyph(x+.7*size*c.xy-2.*index*size*c.xy, 48.+ca, .7*size));\n"
"    index += 1.;\n"
"    ca = floor(exp-10.*ca);\n"
"    d = min(d, dglyph(x+.7*size*c.xy-2.*index*size*c.xy, 48.+ca, .7*size));\n"
"    index += 1.;\n"
"    \n"
"    return d;\n"
"}\n"
"\n"
"// Distance to 210 logo\n"
"float logo(vec2 x, float r)\n"
"{\n"
"    return min(\n"
"        min(circle(x+r*c.zy, r), lineseg(x,r*c.yz, r*c.yx)),\n"
"        circlesegment(x+r*c.xy, r, -.5*pi, .5*pi)\n"
"    );\n"
"}\n"
"\n"
"// Distance to stroke for any object\n"
"float stroke(float d, float w)\n"
"{\n"
"    return abs(d)-w;\n"
"}\n"
"\n"
"// Distance to hexagon pattern\n"
"vec2 ind;\n"
"float hexagon( vec2 p ) \n"
"{\n"
"    vec2 q = vec2( p.x*1.2, p.y + p.x*0.6 );\n"
"    \n"
"    vec2 pi = floor(q);\n"
"    vec2 pf = fract(q);\n"
"\n"
"    float v = mod(pi.x + pi.y, 3.);\n"
"\n"
"    float ca = step(1.,v);\n"
"    float cb = step(2.,v);\n"
"    vec2  ma = step(pf.xy,pf.yx);\n"
"    \n"
"    ind = pi + ca - cb*ma;\n"
"    \n"
"    return dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n"
"}\n"
"\n"
"// extrusion\n"
"float zextrude(float z, float d2d, float h)\n"
"{\n"
"    vec2 w = vec2(-d2d, abs(z)-.5*h);\n"
"    return length(max(w,0.));\n"
"}\n"
"\n"
"float box( vec3 x, vec3 b )\n"
"{\n"
"    return length(max(abs(x) - b,0.));\n"
"}\n"
"\n"
"vec2 inset(vec3 x)\n"
"{\n"
"    float rs = 1.9;\n"
"    return vec2(min(x.y+.4, abs(length(x)-rs+.15)), 9.);\n"
"}\n"
"\n"
"vec2 inset2(vec3 x)\n"
"{\n"
"    float rs = 1.9;\n"
"    return vec2(abs(length(x)-rs+.15), 9.);\n"
"}\n"
"\n"
"// Hangar scene\n"
"vec2 scene(vec3 x) \n"
"{\n"
"    // Start with floor (floor material: 1)\n"
"    // Water: /*+.01*snoise_2d(2.*x.xz-iTime)+.01*snoise_2d(4.1*x.xz-iTime*c.yx)*/\n"
"    vec2 sdf = vec2(x.y+.4, 1.);\n"
"        \n"
"    // Add glass sphere (glass material: 2)\n"
"    float rs = 1.9;\n"
"//     sdf = add(sdf, vec2(stroke(length(x)-rs,.05), 2.));\n"
"\n"
"    // Add skydome\n"
"    //sdf = add(sdf, vec2(abs(length(x)-2.*rs), 0.));\n"
"    \n"
"    // Add hexagonal windows to glass sphere (ceil material: 3)\n"
"    vec2 pt = vec2(atan(x.x,x.y+.4), -acos(x.z/length(x+.4*c.yxy)));\n"
"    float d = stroke(zextrude(length(x)-rs,-stroke(hexagon(vec2(5.,10.)*pt), .1),.1), .05);\n"
"    sdf = add(sdf, vec2(d, 3.));\n"
"    \n"
"    // Make some of the windows closed.\n"
"    if(rand(ind) < .5)\n"
"    {\n"
"        float d = stroke(zextrude(length(x)-rs,stroke(hexagon(vec2(5.,10.)*pt), .1),.1), .01);\n"
"        sdf = add(sdf, vec2(d, 2.));\n"
"    }\n"
"    \n"
"    // Add floor panel below windows, material: 4\n"
"    d = stroke(zextrude(x.y+.4, -stroke(length(x.xz)-rs,.1),.1),.05);\n"
"    sdf = add(sdf, vec2(d, 4.));\n"
"    \n"
"    // Add mountains in the background\n"
"    sdf = add(sdf, vec2(x.y+.45-.1*step(rs, length(x.xz))-(.5+mfsnoise_2d(x.xz, 2., 4.e3, .35))*smoothstep(1.3*rs, 4.*rs, length(x.xz)), 4.));\n"
"    \n"
"    // Add lamps\n"
"    // TODO: circle of lamps that look like cups with spheres in them\n"
"    /*\n"
"    vec3 z = x+.7*rs*c.yyx-.6*c.yxy;\n"
"    float rl = .2;\n"
"    d = length(z)-rl;\n"
"    sdf = add(sdf, vec2(d, 6.));\n"
"    */\n"
"    // Add piano\n"
"    \n"
"    // Add guard objects for debugging\n"
"    float dr = .2;\n"
"    vec3 y = mod(x,dr)-.5*dr;\n"
"    float guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .6),0.));\n"
"    guard = abs(guard)+dr*.1;\n"
"    sdf.x = min(sdf.x, guard);\n"
"    \n"
"//     sdf.x = abs(sdf.x)-.008;\n"
"    return sdf;\n"
"    \n"
"//     return vec2(abs(sdf.x)-.001, sdf.y);\n"
"}\n"
"\n"
"// Greetings scene\n"
"vec2 greetings(vec3 x)\n"
"{\n"
"    vec2 sdf = c.xy;\n"
"    \n"
"    return sdf;\n"
"}\n"
"\n"
"// graph traversal for 210 logo effect\n"
"vec2 textpre(vec3 x)\n"
"{\n"
"    vec2 sdf =  vec2(x.z, 7.);\n"
"    float structure = stroke(logo(x.xy+.3*c.xy,.6),.25);\n"
"    float blend = smoothstep(2., 6., iTime)*(1.-smoothstep(6.,12.,iTime));\n"
"    if(structure < 0. && blend >= 1.e-3)\n"
"    {\n"
"        sdf = vec2(stroke(zextrude(x.z, 1.5*x.z-stroke(logo(x.xy+.3*c.xy,.6),.25), 1.*blend*clamp(1.-exp(-(x.x-34.)-8.*iTime), 0., .5)), .05*blend), 7.);\n"
"    }\n"
"    sdf.x = abs(sdf.x)-.3;\n"
"    return sdf;\n"
"}\n"
"\n"
"// graph traversal for endeavour text effect\n"
"vec2 textpre2(vec3 x)\n"
"{\n"
"    float blend = smoothstep(15., 16., iTime)*(1.-smoothstep(24.,25.,iTime));\n"
"    vec2 sdf = vec2(min(x.z, box(x, vec3(2.,1.6,.25*iScale*blend))), 7.);\n"
"    return sdf;\n"
"}\n"
"\n"
"// 3D Effect on text in intro (210 logo)\n"
"vec2 texteffect(vec3 x)\n"
"{\n"
"    // Start with z=0 plane\n"
"    vec2 sdf = vec2(x.z, 7.);\n"
"    float hex = hexagon(18.*x.xy);\n"
"    \n"
"    // compute hexagon indices in cartesian coordinates\n"
"    vec2 cind = ind/18.;\n"
"    cind = vec2(cind.x/1.2, cind.y);\n"
"    cind = vec2(cind.x, cind.y-cind.x*.6);\n"
"    \n"
"    // build up team210 logo (t < 12.)\n"
"    float structure = stroke(logo(cind+.3*c.xy,.6),.25);\n"
"    float blend = smoothstep(2., 6., iTime)*(1.-smoothstep(6.,12.,iTime));\n"
"    if(structure < 0. && blend >= 1.e-3)\n"
"    {\n"
"        float blend = smoothstep(2., 6., iTime)*(1.-smoothstep(6.,12.,iTime));\n"
"        sdf = vec2(stroke(zextrude(x.z, 2.*x.z-stroke(logo(cind.xy+.3*c.xy,.6),.25), (.5+.5*snoise_2d(24.*cind.xy-iTime))*blend*clamp(1.-exp(-(ind.x-34.)-8.*iTime), 0., 1.)), .05*blend), 7.);\n"
"    }\n"
"    \n"
"    // Add guard objects for debugging\n"
"    float dr = .03;\n"
"    vec3 y = mod(x,dr)-.5*dr;\n"
"    float guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .6),0.));\n"
"    guard = abs(guard)+dr*.1;\n"
"    sdf.x = min(sdf.x, guard);\n"
"    \n"
"    return sdf;\n"
"}\n"
"\n"
"vec2 texteffect2(vec3 x) // text effect for endeavor text (bounce with rhythm\n"
"{\n"
"    vec2 sdf = vec2(x.z, 7.);\n"
"    float hex = hexagon(18.*x.xy);\n"
"    \n"
"    // compute hexagon indices in cartesian coordinates\n"
"    vec2 cind = ind/18.;\n"
"    cind = vec2(cind.x/1.2, cind.y);\n"
"    cind = vec2(cind.x, cind.y-cind.x*.6);\n"
"    \n"
"    // build up endeavour text\n"
"    // Show demo name: \"Endeavor\" (t < 25.)\n"
"    float endeavor = dstring(cind+2.*(1.2*iTime-22.8)*c.xy, 0., .8);\n"
"    endeavor = stroke(endeavor, .2);\n"
"    float structure = mix(0., endeavor, clamp(.25*(iTime-14.), 0., 1.));\n"
"    float blend = smoothstep(15., 16., iTime)*(1.-smoothstep(24.,25.,iTime));\n"
"    if(structure < 0. && blend >= 1.e-3)\n"
"    {\n"
"        sdf = vec2(stroke(zextrude(x.z, -endeavor, .25*iScale*(.5+.5*snoise_2d(24.*cind.xy-iTime))*blend), .05*blend), 7.);\n"
"    }\n"
"\n"
"    // Add guard objects for debugging\n"
"//     float dr = .04;\n"
"//     vec3 y = mod(x,dr)-.5*dr;\n"
"//     float guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .6),0.));\n"
"//     guard = abs(guard)+dr*.1;\n"
"//     sdf.x = min(sdf.x, guard);\n"
"    \n"
"    return sdf;\n"
"}\n"
"\n"
"vec3 post1(vec2 uv, vec3 col)\n"
"{\n"
"    if(uv.y < .8) \n"
"    {\n"
"        // scanlines\n"
"        col += vec3(0., 0.05, 0.1)*sin(uv.y*1050.+ 5.*iTime);\n"
"        col = clamp(col,c.yyy,c.xxx);\n"
"        return col;\n"
"    }\n"
"    \n"
"    // Preparations\n"
"    vec3 blu = vec3(.2, .68, 1.);\n"
"    float px = 1.5/iResolution.y;\n"
"    \n"
"    // 210 logo\n"
"    float dt0 = logo(uv-2.*vec2(-.45*a,.45),.04);\n"
"    dt0 = stroke(dt0, .01);\n"
"    col = mix(col, mix(col, blu, .5), smoothstep(px, -px ,dt0));\n"
"    dt0 = stroke(dt0, .0025);\n"
"    col = mix(col, blu, smoothstep(px, -px ,dt0));\n"
"    \n"
"    // bounding box for time display\n"
"    dt0 = stroke(lineseg(uv-2.*vec2(-.45*a, .45)-.2*c.xy, c.yy, 1.*c.xy), .05);\n"
"    col = mix(col, mix(col, blu, .5), smoothstep(px, -px, dt0));\n"
"    float dt1 = stroke(dt0, .0025);\n"
"    col = mix(col, blu, smoothstep(px, -px, dt1));\n"
"    \n"
"    // \"elapsed:\" text with time display\n"
"    float dta = dstring(uv-2.*vec2(-.45*a,.45)-.3*c.xy,1., .025);\n"
"    dta = min(dta, dfloat(uv-2.*vec2(-.45*a,.45)-.7*c.xy, iTime, .025));\n"
"    dta = stroke(dta, .0025);\n"
"    col = mix(col, clamp(1.*blu, 0., 1.), smoothstep(px, -px, dta));\n"
"    \n"
"    // bounding box for size display\n"
"    dt0 = stroke(lineseg(uv-2.*vec2(-.45*a, .45)-1.4*c.xy, c.yy, 1.*c.xy), .05);\n"
"    col = mix(col, mix(col, blu, .5), smoothstep(px, -px, dt0));\n"
"    dt1 = stroke(dt0, .0025);\n"
"    col = mix(col, blu, smoothstep(px, -px, dt1));\n"
"    \n"
"    // \"size:\" text with size\n"
"    dta = dstring(uv-2.*vec2(-.45*a,.45)-1.5*c.xy,2., .025);\n"
"    dta = min(dta, dfloat(uv-2.*vec2(-.45*a,.45)-1.7*c.xy, iExecutableSize, .025));\n"
"    dta = stroke(dta, .0025);\n"
"    col = mix(col, clamp(1.*blu, 0., 1.), smoothstep(px, -px, dta));\n"
"    \n"
"    // scanlines\n"
"    col += vec3(0., 0.05, 0.1)*sin(uv.y*1050.+ 5.*iTime);\n"
"    col = clamp(col,c.yyy,c.xxx);\n"
"    \n"
"    return col;\n"
"}\n"
"\n"
"//performs raymarching\n"
"//scene: name of the scene function\n"
"//xc: 	 name of the coordinate variable\n"
"//ro:	 name of the ray origin variable\n"
"//d:	 name of the distance variable\n"
"//dir:	 name of the direction variable\n"
"//s:	 name of the scenestruct variable\n"
"//N:	 number of iterations used\n"
"//eps:	 exit criterion\n"
"//flag:  name of the flag to set if raymarching succeeded\n"
"#define raymarch(scene, xc, ro, d, dir, s, N, eps, flag) \\\n"
"    {\\\n"
"        flag = false;\\\n"
"        for(int ia=0; ia<max(N,0); ++ia)\\\n"
"        {\\\n"
"            xc = ro + d*dir;\\\n"
"            s = scene(xc);\\\n"
"            if(s.x < eps)\\\n"
"            {\\\n"
"                flag = true;\\\n"
"                break;\\\n"
"            }\\\n"
"            d += s.x;\\\n"
"        }\\\n"
"    }\n"
"\n"
"//computes normal with finite differences\n"
"//scene: name of the scene function\n"
"//n:	 name of the normal variable\n"
"//eps:	 precision of the computation\n"
"//xc:	 location of normal evaluation\n"
"#define calcnormal(scene, _n, eps, xc) \\\n"
"    {\\\n"
"        float ss = scene(xc).x;\\\n"
"        _n = normalize(vec3(scene(xc+eps*c.xyy).x-ss,\\\n"
"                        scene(xc+eps*c.yxy).x-ss,\\\n"
"                        scene(xc+eps*c.yyx).x-ss));\\\n"
"    }\n"
"\n"
"//camera setup\n"
"//camera: camera function with camera(out vec3 ro, out vec3 r, out vec3 u, out vec3 t)\n"
"//ro:	  name of the ray origin variable\n"
"//r:	  name of the right variable\n"
"//u:	  name of the up variable\n"
"//t:	  name of the target variable\n"
"//uv:	  fragment coordinate\n"
"//dir:	  name of the dir variable\n"
"#define camerasetup(camera, ro, r, u, t, uv, dir) \\\n"
"    {\\\n"
"        camera(ro, r, u, t);\\\n"
"        t += uv.x*r+uv.y*u;\\\n"
"        dir = normalize(t-ro);\\\n"
"    }\n"
"\n"
"        //uv += .02*vec2(snoise_2d(uv-iTime+2.),snoise_2d(uv-iTime+3.));\\\n"
"//post processing: 210 logo and trendy display lines\n"
"//col: output color\n"
"//uv:  fragment coordinate\n"
"#define post(color, uv) \\\n"
"    {\\\n"
"        color = post1(uv, color);\\\n"
"    }\n"
"    \n"
"//camera for scene 1\n"
"void camera1(out vec3 ro, out vec3 r, out vec3 u, out vec3 t)\n"
"{\n"
"    ro = c.yyx;//-1.*c.yyx+.1*(iTime-28.)*c.yyx;\n"
"    r = c.xyy;\n"
"    u = c.yxy;\n"
"    t = c.yyy;//-1.*c.yyx+.1*(iTime-28.)*c.yyx;\n"
"}\n"
"\n"
"// static camera\n"
"void camera0(out vec3 ro, out vec3 r, out vec3 u, out vec3 t)\n"
"{\n"
"    float blend = 0.;// smoothstep(2., 6., iTime)*(1.-smoothstep(6.,12.,iTime));\n"
"    ro = c.yyx-.5*c.yxy*blend;\n"
"    r = c.xyy;\n"
"    u = c.yxy+.5*c.yyx*blend;\n"
"    t = .1*c.yyx;\n"
"}\n"
"\n"
"vec3 stdcolor(vec2 x)\n"
"{\n"
"    return 0.5 + 0.5*cos(iTime+x.xyx+vec3(0,2,4));\n"
"}\n"
"\n"
"float star(vec2 x, float r0)\n"
"{\n"
"    return 1.-smoothstep(.5*r0, r0, length(x));\n"
"}\n"
"\n"
"vec3 background(vec2 x)\n"
"{\n"
"    // Add sky gradient\n"
"    vec3 col = mix(vec3(1., .56, .44), vec3(1.,1.,.87), abs(x.y));\n"
"    \n"
"    // Add sun\n"
"    float d = length(vec2(x.x, abs(x.y+.15))-.3*c.yx)-.15;\n"
"//     col = mix(col, c.xxx, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n"
"    \n"
"    // Add clouds\n"
"    float da = .5+.5*snoise_2d(5.*vec2(x.x, abs(x.y+.15))-.4*iTime);\n"
"    float dx = .5*(da+.5+.5*mfsnoise_2d(vec2(x.x-.2*iTime, abs(x.y+.15)), 1.e1, 1.e4, .45));\n"
"    col = mix(col, vec3(1.,.7,.57), clamp(dx, 0., 1.));\n"
"    col = mix(col, .9*vec3(1.,.7,.57), clamp(.14+dx, 0., 1.));\n"
"    col = mix(col, .8*vec3(1.,.7,.57), clamp(.05+dx, 0., 1.));\n"
"    \n"
"    // And more clouds\n"
"//     da = .5+.5*snoise_2d(2.*vec2(x.x, abs(x.y+.15))-.4*iTime-15.);\n"
"//     dx = .5*(da+.5+.5*mfsnoise_2d(vec2(x.x-.1*iTime-15., abs(x.y+.15)), 1.e0, 1.e3, .55));\n"
"//     col = mix(col, .8*vec3(1.,1.,.87), clamp(.15+dx, 0., 1.));\n"
"//     col = mix(col, .9*vec3(1.,1.,.87), clamp(.12+dx, 0., 1.));\n"
"//     col = mix(col, vec3(1.,1.,.87), clamp(.09+dx, 0., 1.));\n"
"    \n"
"    col = mix(col, c.xxx, .4*smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n"
"    \n"
"    \n"
"    return col;\n"
"}\n"
"\n"
"// Initial intro\n"
"vec3 background2(vec2 uv)\n"
"{\n"
"    // hexagonal grid\n"
"    float d = stroke(-hexagon(18.*uv), .1);\n"
"    \n"
"    // compute hexagon indices in cartesian coordinates\n"
"    vec2 cind = ind/18.;\n"
"    cind = vec2(cind.x/1.2, cind.y);\n"
"    cind = vec2(cind.x, cind.y-cind.x*.6);\n"
"    \n"
"    // build up team210 logo (t < 12.)\n"
"    float structure = exp(-(ind.x-34.)-8.*iTime)+stroke(logo(cind+.3*c.xy,.6),.25);\n"
"    \n"
"    // blend to gray (t < 16.)\n"
"    structure = mix(structure, hexagon(18.*uv), clamp(.25*(iTime-12.), 0., 1.));\n"
"    \n"
"    vec2 dind = cind;\n"
"    \n"
"    // Show demo name: \"Endeavor\" (t < 25.)\n"
"    float endeavor = dstring(cind+2.*(-6.+1.2*iTime-1.2*14.)*c.xy, 0., .8);\n"
"    endeavor = stroke(endeavor, .2);\n"
"    structure = mix(structure, endeavor, clamp(.25*(iTime-14.), 0., 1.));\n"
"    \n"
"    // blend hexagons smaller (t < 27.)\n"
"    d = mix(d, stroke(-hexagon(8.*uv), .1), clamp(.5*(iTime-24.), 0., 1.));\n"
"    structure = mix(structure, hexagon(8.*uv), clamp(.5*(iTime-24.), 0., 1.));\n"
"    dind = ind/8.;\n"
"    dind = vec2(dind.x/1.2, dind.y);\n"
"    dind = vec2(dind.x, dind.y-dind.x*.6);\n"
"    cind = mix(cind, dind,  clamp(.5*(iTime-24.), 0., 1.));\n"
"    \n"
"    // make background change the color with time\n"
"    vec2 dt = vec2(snoise_2d(5.*cind+2.),snoise_2d(5.*cind+3.));\n"
"    float m = (.5+.5*snoise_2d(50.*cind)\n"
"        + mix(-1.,clamp(.5+.5*snoise_2d(.5*(cind)-dt-2.*iTime*c.xx),0.,1.), clamp(.125*(iTime-1.),0.,1.)));\n"
"    vec3 c1 = mix(c.yyy, c.yyy,m)*smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, d);\n"
"        c1 = mix(c1, mix(c.yyy, vec3(1.,0.27,0.),m), smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, stroke(structure,.05)))*smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, d);\n"
"    c1 = clamp(c1, 0., 1.);\n"
"    \n"
"    // grayscale everything outside the structure\n"
"    if(structure > 0.)\n"
"        c1 = mix(.3*length(c1)*c.xxx/sqrt(3.), c1, clamp(.5*(iTime-24.), 0., 1.));\n"
"    \n"
"    // blend to black at the end\n"
"    c1 = mix(c1, c.yyy, clamp(iTime-27., 0., 1.));\n"
"    \n"
"    return clamp(c1,0.,1.);\n"
"}\n"
"\n"
"vec3 color(float rev, float ln, float mat, vec2 uv, vec3 x)\n"
"{\n"
"    if(mat == 2.)\n"
"    {\n"
"        vec3 col = .1*c.xyy + .3*c.xyy * abs(ln) + .8*c.xxy * abs(pow(rev,8.));\n"
"        vec2 pt = vec2(atan(x.x,x.y+.4), -acos(x.z/length(x+.4*c.yxy)));\n"
"        float d = stroke(-hexagon(6.*vec2(5.,10.)*pt), .1);\n"
"        float m = rand(ind/*+floor(2.*iTime)*/);\n"
"        col = mix(col, mix(col, vec3(1.,0.27,0.),m), smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, d));\n"
"        return col;\n"
"    }\n"
"    if(mat == 7.)\n"
"        return background2(x.xy);\n"
"    if(mat == 6.)\n"
"        return clamp(.7*c.xxx + .7*c.xxy*abs(ln) + c.xxx*abs(pow(rev,8.)), 0., 1.);\n"
"    if(mat == 9.)\n"
"        return c.xyy;\n"
"    return .1*c.xyy + .3*c.xyy * abs(ln) + .8*c.xxy * abs(pow(rev,8.));\n"
"}\n"
"\n"
"// Revision logo of width 1.\n"
"float drevision(vec2 x)\n"
"{\n"
"    float l = length(x),\n"
"        p = atan(x.y,x.x),\n"
"        d = abs(l-.07)-.02, \n"
"        k1 = abs(l-.16)-.03,\n"
"        k2 = abs(l-.21)-.02, \n"
"        k3 = abs(l-.35)-.03,\n"
"        k4 = abs(l-.45)-.02;\n"
"    d = min(d, mix(d, abs(l-.11)-.03, step(p, -1.71)*step(-2.73, p)));\n"
"    d = min(d, mix(d, k1, step(p, 3.08)*step(2.82,p)));\n"
"    d = min(d, mix(d, k1, step(p, 1.47)*step(.81,p)));\n"
"    d = min(d, mix(d, k1, step(p, -.43)*step(-1.19,p)));\n"
"    d = min(d, mix(d, k2, step(p, -2.88)*step(-pi,p)));\n"
"    d = min(d, mix(d, k2, step(p, pi)*step(2.38,p)));\n"
"    d = min(d, mix(d, k2, step(p, 2.1)*step(.51,p)));\n"
"    d = min(d, mix(d, k2, step(p, .3)*step(-1.6,p)));\n"
"    d = min(d, abs(l-.24)-.02);\n"
"    d = min(d, mix(d, k3, step(p, -2.18)*step(-pi, p)));\n"
"    d = min(d, mix(d, k3, step(p, -1.23)*step(-1.7, p)));\n"
"    d = min(d, mix(d, k3, step(p, -.58)*step(-.78, p)));\n"
"    d = min(d, mix(d, k3, step(p, 0.)*step(-.29, p)));\n"
"    d = min(d, mix(d, k3, step(p, 1.25)*step(1.06, p)));\n"
"    d = min(d, mix(d, k3, step(p, 1.99)*step(.5*pi, p)));\n"
"    d = min(d, abs(l-.41)-.03);\n"
"    d = min(d, mix(d, k4, step(p, 1.04)*step(.04, p)));\n"
"    d = min(d, mix(d, k4, step(p, -2.2)*step(-2.34, p)));\n"
"    \n"
"    return d-.005;\n"
"}\n"
"\n"
"vec3 smallogo(vec2 uv)\n"
"{\n"
"    if(iTime < 33.)\n"
"    {\n"
"        uv *= rot2(iTime);\n"
"        float d = drevision(uv), d2 = abs(d-.01)-.002;\n"
"        vec3 col = mix(c.yyy, (.3+.4*iScale)*c.xxx, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n"
"        col = mix(col, vec3(1.,0.27,0.), smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d2));\n"
"        col *= smoothstep(28., 29., iTime)*(1.-smoothstep(32., 33., iTime));\n"
"        return col;\n"
"    }\n"
"    else\n"
"    {\n"
"        \n"
"    }\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n"
"{\n"
"//     iScale = scale(iTime+.1); //TODO: ADD THIS! IT SYNCS\n"
"    a = iResolution.x/iResolution.y;\n"
"    vec3 ro, r, u, t, x, dir;\n"
"    vec2 s = c.xy, uv;\n"
"    \n"
"    float d = 0.;\n"
"    bool hit = false;\n"
"    \n"
"    vec3 col = c.yyy;\n"
"    \n"
"    // Antialiasing\n"
"    for(int jii=0; jii<max(iFSAA, 0); ++jii)\n"
"        for(int jij=0; jij<max(iFSAA,0); ++jij)\n"
"        {\n"
"        vec2 o = vec2(float(jii),float(jij)) / float(iFSAA) - .5;\n"
"        uv = (-iResolution.xy + 2.*(fragCoord+o))/iResolution.y;\n"
"\n"
"        // Test font glyphs TODO: Remove\n"
"    //     if(iTime < 1000.)\n"
"    //     {\n"
"    //         float ds = .1;\n"
"    //         // Need 32-126\n"
"    //         vec2 xa = mod(uv+iResolution.xy/iResolution.y, ds)-.5*ds,\n"
"    //         ind = ceil((uv-xa)/ds);\n"
"    //         float da = dglyph(xa,  32.+ind.x+20.*ind.y, .3*ds);\n"
"    //         da = stroke(da, .1*ds);\n"
"    //         col += mix(c.yyy, c.xxx, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, da));\n"
"    //     }\n"
"    //     else \n"
"    //================================\n"
"//         if(iTime < 1000.)\n"
"//         {\n"
"//     // // //         vec3 c1 = texture(iSequence, uv).rgb;\n"
"//             vec3 c1 = c.yyy;\n"
"// //             float st = scale(iTime);\n"
"//             iScale = scale(iTime-uv.x);\n"
"//             if(uv.y > 0.)  \n"
"//             {\n"
"//                 c1 += c.xyy*step(uv.y,iScale);\n"
"//                 c1 += c.yyx*step(uv.y,iNBeats/16.);\n"
"//             }\n"
"//             c1 = mix(c1, c.xxy, step(abs(uv.x), .01));\n"
"//             col += c1;\n"
"//         }\n"
"//         if(iTime < 1000.)\n"
"//         {\n"
"//             float d = dglyph(uv, 57., .1);\n"
"//             //float d = dstring(uv-.1, 1., .05);\n"
"//             float d = dfloat(uv, rfloats(3.), .05);\n"
"//             if(d == 1.)col += c.yxy;\n"
"//             else\n"
"//             {\n"
"//                 d = stroke(d, .01);\n"
"//                 col +=  mix(c.yyy, c.xyy, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, d));\n"
"//             }\n"
"//         }\n"
"//         else\n"
"        if(iTime < 16.) // Team210 Logo \n"
"        {\n"
"            vec3 c1 = c.yyy;\n"
"            \n"
"            camerasetup(camera0, ro, r, u, t, uv, dir);\n"
"            d = (.5-ro.z)/dir.z;\n"
"            raymarch(textpre, x, ro, d, dir, s, 100, 2.e-4, hit);\n"
"            if(hit) hit = false;\n"
"            else d = -ro.z/dir.z;\n"
"            raymarch(texteffect, x, ro, d, dir, s, 200, 2.e-4, hit);\n"
"            \n"
"            if(hit)\n"
"            {\n"
"                vec3 n;\n"
"                calcnormal(texteffect, n, 2.e-4, x);\n"
"\n"
"                float rs = 1.9;\n"
"                vec3 l = x+1.*c.yyx,\n"
"                    re = normalize(reflect(-l,n));\n"
"                float rev = abs(dot(re,dir)), ln = abs(dot(l,n));\n"
"\n"
"                c1 = color(rev, ln, s.y, uv, x);\n"
"            }\n"
"            else c1 = background2((ro-ro.z/dir.z*dir).xy);\n"
"            \n"
"            col += c1;\n"
"        }\n"
"//         else if(iTime < 28.) // \"Endeavour\" text\n"
"//         {\n"
"//             vec3 c1 = c.yyy;\n"
"//             camerasetup(camera0, ro, r, u, t, uv, dir);\n"
"//             d = (.25-ro.z)/dir.z;\n"
"//             raymarch(textpre2, x, ro, d, dir, s, 50, 2.e-4, hit);\n"
"//             if(!hit) \n"
"//             {\n"
"//                 d = -ro.z/dir.z;\n"
"//             }\n"
"//             raymarch(texteffect2, x, ro, d, dir, s, 200, 2.e-4, hit);\n"
"//             \n"
"//             if(hit)\n"
"//             {\n"
"//                 vec3 n = c.yyy;\n"
"//                 calcnormal(texteffect2, n, 2.e-4, x); //BUG\n"
"// \n"
"//                 float rs = 1.9;\n"
"//                 vec3 l = x+1.*c.yyx,\n"
"//                     re = normalize(reflect(-l,n));\n"
"//                 float rev = abs(dot(re,dir)), ln = abs(dot(l,n));\n"
"// \n"
"//                 c1 = color(rev, ln, s.y, uv, x);\n"
"//             }\n"
"//             else \n"
"//             {\n"
"//                 c1 = background2((ro-ro.z/dir.z*dir).xy);\n"
"//             }\n"
"//             \n"
"//             col += c1;\n"
"//         }\n"
"        else if(iTime < 38.) // Endeavour small logo; revision logo\n"
"        {\n"
"            col += smallogo(uv);\n"
"        }\n"
"//         else \n"
"        else if(iTime < 10000.)\n"
"        {\n"
"            //hexagon((2.+2.*iTime)*vec2(5.,10.)*uv);\n"
"            hexagon((2.+2.*(iTime-38.))*vec2(5.,10.)*uv);\n"
"            //uv = mix(ind, uv, smoothstep(0., 4., iTime)); // TODO: add smooth transition from 2d texture\n"
"            uv = mix(ind, uv, smoothstep(38., 42., iTime)); // TODO: add smooth transition from 2d texture\n"
"        \n"
"            vec3 c1 = c.yyy;\n"
"            camerasetup(camera1, ro, r, u, t, uv, dir);\n"
"            d = 0.;\n"
"            raymarch(inset, x, ro, d, dir, s, 40, 1.e-4, hit);\n"
"            raymarch(scene, x, ro, d, dir, s, 250, 1.e-4, hit);\n"
"            \n"
"            if(hit)\n"
"            {\n"
"                vec3 n;\n"
"                calcnormal(scene, n, 2.e-4, x);\n"
"\n"
"                float rs = 1.9;\n"
"                vec3 l = -1.*c.yxy+1.5*c.yyx, \n"
"                    re = normalize(reflect(-l,n));\n"
"                float rev = abs(dot(re,dir)), ln = abs(dot(l,n));\n"
"\n"
"                c1 = color(rev, ln, s.y, uv, x);\n"
"\n"
"                // Reflections\n"
"                if(s.y == 1.)\n"
"                {\n"
"                    dir = reflect(dir, n);\n"
"                    d = -1.1e-4;//1.1e-4;\n"
"                    ro = x;\n"
"                    raymarch(inset2, x, ro, d, dir, s, 40, 1.e-4, hit);\n"
"                    raymarch(scene, x, ro, d, dir, s, 250, 1.e-4, hit);\n"
"                    if(hit)\n"
"                    {\n"
"                        vec3 n2 = c.yyy;\n"
"                        calcnormal(scene, n2, 2.e-4, x);\n"
"                        re = normalize(reflect(-l,n2));\n"
"                        rev = abs(dot(re,dir));\n"
"                        ln = abs(dot(l,n2));\n"
"                        c1 = mix(c1, color(rev, ln, s.y, uv, x), .7);\n"
"                    }\n"
"                    else c1 = mix(c1,background(uv), .7);\n"
"                }\n"
"            }\n"
"            else c1 = background(uv);\n"
"\n"
"            // lens flare\n"
"            for(float k=0.; k<8.; k+=1.)\n"
"            {\n"
"                vec2 dx = .15*vec2(-1.+2.*rand(c.xx+k), -1.+2.*rand(c.xx+k+1.));\n"
"                vec3 cx = c.xxx-.2*vec3(rand(c.xx+k+2.), rand(c.xx+k+3.), rand(c.xx+k+4.));\n"
"                float sx = .05+.05*rand(c.xx+k+5.);\n"
"                float da = dpoly_min(uv-.15*c.yx+dx, 6., sx);\n"
"                c1 = mix(c1, mix(c1,cx, .5), smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, da));\n"
"            }\n"
"            \n"
"            // fog\n"
"            //c1 = mix(c1, mix(vec3(1., .56, .44), vec3(1.,1.,.87), abs(uv.y)), tanh(.*d));\n"
"            \n"
"            col += c1;\n"
"//             col += mix(mix(c.yyy, c1, clamp(iTime-29., 0., 1.)), c.yyy, clamp(iTime-44., 0., 1.));\n"
"        }\n"
"        \n"
"    }\n"
"    col /= float(iFSAA*iFSAA);\n"
"    \n"
"    // Post-process\n"
"    post(col, uv);\n"
"    \n"
"    // Set the fragment color\n"
"    fragColor = vec4(col, 1.);    \n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
