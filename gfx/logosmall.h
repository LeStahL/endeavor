/* Generated with shader-compressor by NR4/Team210. */
#ifndef LOGOSMALL_H
#define LOGOSMALL_H
const char * logosmall_frag =
"/* Endeavor by Team210 - 64k intro by Team210 at Revision 2k19\n"
" * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n"
" *\n"
" * This program is free software: you can redistribute it and/or modify\n"
" * it under the terms of the GNU General Public License as published by\n"
" * the Free Software Foundation, either version 3 of the License, or\n"
" * (at your option) any later version.\n"
" *\n"
" * This program is distributed in the hope that it will be useful,\n"
" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
" * GNU General Public License for more details.\n"
" *\n"
" * You should have received a copy of the GNU General Public License\n"
" * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n"
" */\n"
" \n"
"#version 130\n"
"\n"
"uniform float iTime;\n"
"uniform vec2 iResolution;\n"
"\n"
"// Global constants\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.0, 0.0, -1.0);\n"
"float a = 1.0;\n"
"\n"
"// Hash function\n"
"void rand(in vec2 x, out float num)\n"
"{\n"
"    num = fract(sin(dot(x-15. ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"// 2D box\n"
"void dbox(in vec2 x, in vec2 b, out float d)\n"
"{\n"
"	vec2 da = abs(x)-b;\n"
"	d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n"
"}\n"
"\n"
"// Compute distance to regular polygon\n"
"void dpolygon(in vec2 x, in float N, out float d)\n"
"{\n"
"    d = 2.0*pi/N;\n"
"    float t = mod(acos(x.x/length(x)), d)-0.5*d;\n"
"    d = -0.5+length(x)*cos(t)/cos(0.5*d);\n"
"}\n"
"\n"
"// Distance to circle\n"
"void dcircle(in vec2 x, out float d)\n"
"{\n"
"    d = length(x)-1.0;\n"
"}\n"
"\n"
"// Stroke\n"
"void stroke(in float d0, in float s, out float d)\n"
"{\n"
"    d = abs(d0)-s;\n"
"}\n"
"\n"
"// Distance to line segment\n"
"void dlinesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d)\n"
"{\n"
"    vec2 da = p2-p1;\n"
"    d = length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n"
"}\n"
"\n"
"// 2D rotational matrix\n"
"void rot(in float phi, out mat2 m)\n"
"{\n"
"    vec2 cs = vec2(cos(phi), sin(phi));\n"
"    m = mat2(cs.x, -cs.y, cs.y, cs.x);\n"
"}\n"
"\n"
"// Distance to pig ear\n"
"void dear(in vec2 x, out float d)\n"
"{\n"
"    d = abs(2.*x.y)\n"
"        -.95+smoothstep(0.,.5,clamp(abs(x.x),0.,1.))\n"
"        -.5*min(-abs(x.x),.01);\n"
"}\n"
"\n"
"// Distance to a triangle\n"
"void dtriangle(in vec2 x, in vec2 p0, in vec2 p1, in vec2 p2, out float d)\n"
"{\n"
"    vec2 d1 = c.xz*(p1-p0).yx, d2 = c.xz*(p2-p1).yx, d3 = c.xz*(p0-p2).yx;\n"
"    d = -min(\n"
"        dot(p0-x,d1)/length(d1),\n"
"        min(\n"
"            dot(p1-x,d2)/length(d2),\n"
"            dot(p2-x,d3)/length(d3)\n"
"        )\n"
"    );\n"
"}\n"
"\n"
"// Distance to hexagon pattern\n"
"void dhexagonpattern(in vec2 p, out float d, out vec2 ind) \n"
"{\n"
"    vec2 q = vec2( p.x*1.2, p.y + p.x*0.6 );\n"
"    \n"
"    vec2 pi = floor(q);\n"
"    vec2 pf = fract(q);\n"
"\n"
"    float v = mod(pi.x + pi.y, 3.0);\n"
"\n"
"    float ca = step(1.,v);\n"
"    float cb = step(2.,v);\n"
"    vec2  ma = step(pf.xy,pf.yx);\n"
"    \n"
"    d = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n"
"    ind = pi + ca - cb*ma;\n"
"    ind = vec2(ind.x/1.2, ind.y);\n"
"    ind = vec2(ind.x, ind.y-ind.x*.6);\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n"
"{\n"
"    a = iResolution.x/iResolution.y;\n"
"    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0), ind;\n"
"    vec3 col = c.yyy;\n"
"    \n"
"    // Background grid\n"
"    float d = 1., da;\n"
"    dhexagonpattern(25.*uv, d, ind);\n"
"    d/=5.;\n"
"    stroke(d,.005,d);\n"
"    d = mix(d, 1., step(0., min(length(ind/25.)-.34, abs(ind.y/25.)-.1)));\n"
"    col = mix(col, .5*c.xxx, step(d,0.));\n"
"    d = mix(d, -1., step(0., min(length(ind/25.)-.34, abs(ind.y/25.)-.1)));\n"
"    col = mix(col, .1*c.xxx, step(-d+.05, 0.));\n"
"    \n"
"    // Rotating stuff\n"
"    mat2 m, mt;\n"
"    rot(iTime, mt);\n"
"    rot(pi/6.,m);\n"
"    \n"
"    // stripes with hexagons\n"
"    float w = .1, l, d0, d1;\n"
"    vec2 y = mod(uv-1.5*c.xy*iTime, vec2(w,.6*w))-.5*vec2(w,.6*w), yi = (uv-1.5*c.xy*iTime-y)/vec2(w,.6*w);\n"
"    rand(yi, l);\n"
"    rand(yi+1., d0);\n"
"    dlinesegment(y, -.4*l*w*c.xy, .4*w*l*c.xy, d);\n"
"    stroke(d, .01, d);\n"
"    dpolygon(mt*y/w*2.,6.,d1); \n"
"    if(d0 < .5 && abs(yi.y) < 2.+1.3*sin(23.*yi.x-3.*iTime))\n"
"    {\n"
"	    col = mix(col, mix(vec3(0.78,.5*d0,.52),c.yyy,.2), step(mix(d,d1,step(d0,.25)),0.));\n"
"        stroke(d, .004, d);\n"
"        stroke(d1*w/2., .004, d1);\n"
"		col = mix(col, vec3(0.78,.5*d0,.52), step(mix(d,d1,step(d0,.25)),0.));\n"
"    }\n"
"    y = mod(.3*w+uv-1.5*c.xy*iTime, vec2(w,.6*w))-.5*vec2(w,.6*w);\n"
"        yi = (.5*w+uv-1.5*c.xy*iTime-y)/vec2(w,.6*w);\n"
"    rand(yi+5.*c.yx, l);\n"
"    rand(yi+15.*c.yx, d0);\n"
"    dlinesegment(y, -.4*l*w*c.xy, .4*w*l*c.xy, d);\n"
"    stroke(d, .01, d);\n"
"    dpolygon(mt*y/w*2.,6.,d1); \n"
"    if(d0 < .3 && abs(yi.y) < 2.+1.5*sin(18.*yi.x-3.*iTime))\n"
"    {\n"
"	    col = mix(col, mix(vec3(0.78,.5*d0,.78),c.yyy,.2), step(mix(d,d1,step(d0,.25)),0.));\n"
"        stroke(d, .004, d);\n"
"        stroke(d1*w/2., .004, d1);\n"
"		col = mix(col, vec3(0.78,.5*d0,.78), step(mix(d,d1,step(d0,.25)),0.));\n"
"    }\n"
"    \n"
"    uv = 2.* mt * uv;\n"
"    dpolygon(.8*uv,6.,d);\n"
"    col = mix(col, mix(vec3(0.78,0.,.78),col,.7),step(d,0.));\n"
"    stroke(d,.01,d);\n"
"    col = mix(col, vec3(0.78,0.,.78),step(d,0.));\n"
"    \n"
"    // White grid\n"
"    dhexagonpattern(5.*uv, d, ind);\n"
"    d/=5.;\n"
"    stroke(d,.01,d);\n"
"    d = mix(d, 1., step(0., length(uv)-.37));\n"
"    dpolygon(1.02*m*(uv-.215*vec2(a,1.)*c.xz), 6., da);\n"
"    d = mix(d, 1., step(da,0.));\n"
"    col = mix(col, c.xxx, step(d,0.));\n"
"    \n"
"    // Planets\n"
"    float t = mod(iTime, 1.);\n"
"    d = length(uv-mix(c.yy,vec2(.35,0.),t))-mix(.1, .15, t);\n"
"    col = mix(col, mix(c.yyy,vec3(0.52,0.52,.52),.5), step(d,0.));\n"
"    stroke(d,.00475,d);\n"
"    col = mix(col, vec3(0.52,0.52,.52), step(d,0.));\n"
"    d = length(uv-mix(vec2(.35,0.), vec2(.2,-.3),t))-mix(.15, .07,t);\n"
"    col = mix(col, mix(c.yyy,vec3(0.52,0.52,.52),.5), step(d,0.));\n"
"    stroke(d,.00475,d);\n"
"    col = mix(col, vec3(0.52,0.52,.52), step(d,0.));\n"
"    d = length(uv-mix(vec2(.2,-.3), c.yy, t))-mix(.07, .1, t);\n"
"    col = mix(col, mix(c.yyy,vec3(0.52,0.52,.52),.5), step(d,0.));\n"
"    stroke(d,.00475,d);\n"
"    col = mix(col, vec3(0.52,0.52,.52), step(d,0.));\n"
"    \n"
"	// Hexagons\n"
"    dpolygon(3.5*m*(uv+.35*c.xy), 6., d);\n"
"    col = mix(col, mix(vec3(0.78,0.,.52),c.yyy,.2), step(d,0.));\n"
"    stroke(d/3.5,.00675, d);\n"
"    col = mix(col, vec3(0.98,0.,.72), step(d,0.));\n"
"    dpolygon(3.5*m*(uv)+vec2(1.075,.65), 6., d);\n"
"    col = mix(col, mix(vec3(0.78,0.,.52),c.yyy,.2), step(d,0.));\n"
"    stroke(d/3.5,.00675, d);\n"
"    col = mix(col, vec3(0.98,0.,.72), step(d,0.));\n"
"    dpolygon(3.5*m*(uv)-vec2(1.075,.65), 6., d);\n"
"    col = mix(col, mix(vec3(0.78,0.,.52),c.yyy,.2), step(d,0.));\n"
"    stroke(d/3.5,.00675, d);\n"
"    col = mix(col, vec3(0.98,0.,.72), step(d,0.));\n"
"    dpolygon(3.5*m*(uv)+vec2(.0,-1.25), 6., d);\n"
"    col = mix(col, mix(vec3(0.78,0.,.52),c.yyy,.2), step(d,0.));\n"
"    stroke(d/3.5,.00675, d);\n"
"    col = mix(col, vec3(0.98,0.,.72), step(d,0.));\n"
"    \n"
"    col = clamp(col, 0., 1.);\n"
"    \n"
"    fragColor = vec4(col,1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
