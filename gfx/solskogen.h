/* Generated with shader-compressor by NR4/Team210. */
#ifndef SOLSKOGEN_H
#define SOLSKOGEN_H
const char * solskogen_frag =
"/* Endeavor by Team210 - 64k intro by Team210 at Revision 2k19\n"
"* Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n"
"*\n"
"* This program is free software: you can redistribute it and/or modify\n"
"* it under the terms of the GNU General Public License as published by\n"
"* the Free Software Foundation, either version 3 of the License, or\n"
"* (at your option) any later version.\n"
"*\n"
"* This program is distributed in the hope that it will be useful,\n"
"* but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"* GNU General Public License for more details.\n"
"*\n"
"* You should have received a copy of the GNU General Public License\n"
"* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n"
"*/\n"
"\n"
"#version 130\n"
"\n"
"uniform float iTime;\n"
"uniform vec2 iResolution;\n"
"\n"
"// Global constants\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.0, 0.0, -1.0);\n"
"float a = 1.0;\n"
"\n"
"// Hash function\n"
"void rand(in vec2 x, out float num)\n"
"{\n"
"    x += 400.;\n"
"    num = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"// Arbitrary-frequency 2D noise\n"
"void lfnoise(in vec2 t, out float num)\n"
"{\n"
"    vec2 i = floor(t);\n"
"    t = fract(t);\n"
"    //t = ((6.*t-15.)*t+10.)*t*t*t;  // TODO: add this for slower perlin noise\n"
"    t = smoothstep(c.yy, c.xx, t); // TODO: add this for faster value noise\n"
"    vec2 v1, v2;\n"
"    rand(i, v1.x);\n"
"    rand(i+c.xy, v1.y);\n"
"    rand(i+c.yx, v2.x);\n"
"    rand(i+c.xx, v2.y);\n"
"    v1 = c.zz+2.*mix(v1, v2, t.y);\n"
"    num = mix(v1.x, v1.y, t.x);\n"
"}\n"
"\n"
"// Distance to line segment\n"
"void dlinesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d)\n"
"{\n"
"    vec2 da = p2-p1;\n"
"    d = length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n"
"}\n"
"\n"
"// Arbitrary-frequency 2D sharp noise\n"
"void lfsharp(in vec2 t, out float num)\n"
"{\n"
"    vec2 i = floor(t);\n"
"    t = fract(t);\n"
"    //t = ((6.*t-15.)*t+10.)*t*t*t;  // TODO: add this for slower perlin noise\n"
"    vec2 v1, v2;\n"
"    rand(i, v1.x);\n"
"    rand(i+c.xy, v1.y);\n"
"    rand(i+c.yx, v2.x);\n"
"    rand(i+c.xx, v2.y);\n"
"    v1 = c.zz+2.*mix(v1, v2, t.y);\n"
"    num = mix(v1.x, v1.y, t.x);\n"
"}\n"
"\n"
"// Multi-frequency 2D noise\n"
"void mfnoise(in vec2 x, in float fmin, in float fmax, in float alpha, out float num)\n"
"{\n"
"    num = 0.;\n"
"    float a = 1., nf = 0., buf;\n"
"    for(float f = fmin; f<fmax; f = f*2.)\n"
"    {\n"
"        lfnoise(f*x, buf);\n"
"        num += a*buf;\n"
"        a *= alpha;\n"
"        nf += 1.;\n"
"    }\n"
"    num *= (1.-alpha)/(1.-pow(alpha, nf));\n"
"}\n"
"\n"
"// compute distance to regular star\n"
"void dstar(in vec2 x, in float N, in vec2 R, out float dst)\n"
"{\n"
"    //R.x = mix(0.,R.x, (10.*x.y));\n"
"    x.y += .9*abs(x.x);\n"
"    vec2 y = x;\n"
"    float d = pi/N,\n"
"        p0 = acos(x.x/length(x)),\n"
"        p = mod(p0, d),\n"
"        i = mod(round((p-p0)/d),2.);\n"
"    x = length(x)*vec2(cos(p),sin(p));\n"
"    vec2 a = mix(R,R.yx,i),\n"
"    	p1 = a.x*c.xy,\n"
"        ff = a.y*vec2(cos(d),sin(d))-p1;\n"
"   	ff = ff.yx*c.zx;\n"
"  	dst = max(y.y,-dot(x-p1,ff)/length(ff));\n"
"}\n"
"\n"
"// compute distance to regular star\n"
"void dstarhalf(in vec2 x, in float N, in vec2 R, out float dst)\n"
"{\n"
"    //R.x = mix(0.,R.x, (10.*x.y));\n"
"    x.y += .9*abs(x.x);\n"
"    vec2 y = x;\n"
"    float d = pi/N,\n"
"        p0 = acos(x.x/length(x)),\n"
"        p = mod(p0, d),\n"
"        i = mod(round((p-p0)/d),2.);\n"
"    x = length(x)*vec2(cos(p),sin(p));\n"
"    vec2 a = mix(R,R.yx,i),\n"
"    	p1 = a.x*c.xy,\n"
"        ff = a.y*vec2(cos(d),sin(d))-p1;\n"
"   	ff = ff.yx*c.zx;\n"
"  	dst = max(y.y,-dot(x-p1,ff)/length(ff));\n"
"    dst = max(dst, y.x);\n"
"}\n"
"\n"
"void stroke(in float d, in float h, out float dst)\n"
"{\n"
"    dst = abs(d)-h;\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n"
"{\n"
"    a = iResolution.x/iResolution.y;\n"
"    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n"
"    float da =  -clamp(uv.x,-.5*a,0.)/.5/a;\n"
"    vec3 col = c.yyy,\n"
"        ccenter =  mix(vec3(0.79,0.33,0.61), vec3(0.77,0.30,0.33),da);\n"
"    \n"
"    if(uv.y < -.25);\n"
"    else if(uv.y < .2)\n"
"	    col = mix(vec3(0.37,0.23,0.53), ccenter, clamp((uv.y+mix(.25, .45,  da))/mix(.45, .65, da),0.,1.));\n"
"    else\n"
"        col = mix(ccenter, vec3(0.36,0.23,0.52), clamp((uv.y-.2)/.3,0.,1.));\n"
"    \n"
"    vec3 mc = mix(vec3(0.27,0.17,0.45),vec3(0.25,0.10,0.30),1.-clamp((uv.y+.5)/.7, 0., 1.));\n"
"    float mountains, smountains;\n"
"    lfnoise(2.*(uv.x*c.xx), mountains);\n"
"    lfsharp(22.*abs(uv.x*c.xx), smountains);\n"
"    float d = -.05+uv.y-mix(-.25, .05, abs(uv.x-.1)/.5/a) + .1*mix(mountains, .5*smountains, smoothstep(.4,.5,clamp(abs(uv.x)/.5/a,0.,1.)))*uv.x;\n"
"    col = mix(col,mc, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n"
"    \n"
"    if(uv.y < -.25)\n"
"    {\n"
"        uv.x -= .1;\n"
"        vec3 ca = mix( vec3(0.11,0.06,0.20),vec3(0.44,0.14,0.36), clamp((uv.y+.5)/.3, 0.,1.));\n"
"        vec3 sea;\n"
"        lfnoise(5.*uv.y*c.xx, sea.x);\n"
"        lfnoise(25.*uv.y*c.xx+122.1*step(sign(uv.x),0.), d);\n"
"        sea.x = .5*(.3*sea.x+1.4*d);\n"
"        sea = .5*c.xxx+.5*sea;\n"
"        sea *= clamp((1.-smoothstep(-.375,-.15,uv.y)),0.,1.);\n"
"        stroke(uv.x, 2.*sea.x, d);\n"
"        col = mix(col, ca, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n"
"        \n"
"        if(d < 0.)\n"
"        {\n"
"            vec2 delta;\n"
"            lfnoise(43.*uv-iTime-133., delta.x);\n"
"            lfnoise(46.*uv-iTime-333., delta.y);\n"
"            uv += .005*delta;\n"
"        }\n"
"        \n"
"        ca = mix( vec3(0.47,0.15,0.36), vec3(0.68,0.19,0.43), clamp((uv.y+.5)/.3, 0.,1.));\n"
"        lfnoise(5.*uv.y*c.xx, sea.x);\n"
"        lfnoise(25.*uv.y*c.xx+122.1*step(sign(uv.x),0.)-.24*iTime, d);\n"
"        sea.x = .5*(.01*sea.x+.99*d);\n"
"        sea = .5*c.xxx+.5*sea;\n"
"        sea *= clamp(cos(smoothstep(-.5,-.375,uv.y))*(1.-smoothstep(-.375,-.2,uv.y)),0.,1.);\n"
"        stroke(uv.x, 1.2*sea.x, d);\n"
"        col = mix(col, ca, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n"
"        \n"
"        ca = vec3(0.82,0.26,0.55);\n"
"        lfnoise(12.*uv.y*c.xx, sea.x);\n"
"        lfnoise(45.*uv.y*c.xx+122.1*step(sign(uv.x),0.)-.2*iTime, d);\n"
"        sea.x = -.5+.5*(1.9*abs(sea.x)+.99*d);\n"
"        sea = .5*c.xxx+.5*sea;\n"
"        sea *= clamp(cos(smoothstep(-.5,-.175,uv.y))*(1.-smoothstep(-.375,-.2,uv.y)),0.,1.);\n"
"        stroke(abs(uv.x), .4*sea.x, d);\n"
"        col = mix(col, ca, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n"
"        uv.x += .1;\n"
"    }\n"
"\n"
"    vec3 dc;\n"
"    rand(uv-1.e-1*iTime*c.xx+.13, dc.x);\n"
"    rand(uv-1.e-1*iTime*c.xx+.33, dc.y);\n"
"    rand(uv-1.e-1*iTime*c.xx+.53, dc.z);\n"
"    \n"
"    uv.y += .2;\n"
"    uv.y -= .3*sign(uv.x);\n"
"    uv.x  = abs(uv.x)-.75;\n"
"    \n"
"    // Trees\n"
"    float tree;\n"
"    vec2 delta;\n"
"	lfnoise(13.*uv-133.-iTime, delta.x);\n"
"    lfnoise(16.*uv-333.-iTime-.1, delta.y);\n"
"    for(float i=9.; i>=0.; i -= 1.)\n"
"    {\n"
"        vec3 cc = mix(vec3(0.03,0.04,0.24), vec3(0.03,0.04,0.12), i/10.),\n"
"            cc1 = mix(vec3(0.06,0.10,0.31), vec3(0.06,0.06,0.18), i/10.);\n"
"        vec3 rii;\n"
"        rand(i*c.xx, rii.x);\n"
"		rand(i*c.xx+.3, rii.x);\n"
"        rand(i*c.xx+.6, rii.x);\n"
"        uv.x += .01*rii.y;\n"
"        \n"
"    	dstar(uv-.005*delta+(-.5+i*.1)*c.yx, 12.+4.*rii.x, vec2(.105+.03*i+.03*rii.y,.18+.03*i+.03*rii.y), tree);\n"
"    	col = mix(col, cc, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, tree));\n"
"        \n"
"        dstar(uv-.005*delta+(-.5+i*.1)*c.yx, 12.+4.*rii.x, vec2(.105+.03*i-.08+.03*rii.y,.18+.03*i-.08+.03*rii.y), tree);\n"
"    	col = mix(col, cc1, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, tree));\n"
"        uv.x -= .01*rii.y;\n"
"    }\n"
"    \n"
"    col = col + .1*(-.5+dc);\n"
"    \n"
"    col = clamp(col, 0., 1.);\n"
"    col = mix(c.yyy, col, smoothstep(0.,.5,iTime)*(1.-smoothstep(9.5,10.,iTime)));\n"
"    fragColor = vec4(col,1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
